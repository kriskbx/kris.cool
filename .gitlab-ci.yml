# ----------------------------------------------------------------------
# GitLab CI/CD Configuration
# ----------------------------------------------------------------------

# ----------------------------------------------------------------------
# Basics
# ----------------------------------------------------------------------

image: ueberdosis/build-tools:0.23.0

stages:
  - build
  - deploy

# ----------------------------------------------------------------------
# Set default variables
# ----------------------------------------------------------------------

variables:
  # Prefix the docker-compose project name with the path of the current project
  # so you can identify it via docker ps and add the current job id as suffix
  # to allow concurrent stacks
  COMPOSE_PROJECT_NAME: ci-$CI_PROJECT_NAME-$CI_JOB_ID
  # The default image name will be prefixed with build, so we can
  # use GitLabs garbage collection to target them separately from
  # the released images
  IMAGE: $CI_REGISTRY/$CI_PROJECT_PATH/build
  # The name of released images will be prefixed by release and the current
  # branch name
  IMAGE_RELEASE: $CI_REGISTRY/$CI_PROJECT_PATH/release-$CI_COMMIT_REF_SLUG
  # Set the tag of the images to "branch-checksum"
  # It is best practise and really important to build and test images per
  # commit and branch to prevent overlapping and failures.
  TAG: $CI_COMMIT_REF_SLUG-$CI_COMMIT_SHA
  # Set default registry variables which can be overridden to use external
  # docker registries
  REGISTRY: $CI_REGISTRY
  REGISTRY_USER: $CI_REGISTRY_USER
  REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
  # The name of the stack that will be deployed to PROD or DEV. Will be the
  # current project path slug and the current environment. Allows deploying
  # multiple projects and environments to the same Docker Swarm host.
  STACK_NAME: $CI_PROJECT_PATH_SLUG-$CI_ENVIRONMENT_SLUG

# ----------------------------------------------------------------------
# Initialize
# ----------------------------------------------------------------------

before_script:
  # Logs into the docker registry.
  - docker login -u $REGISTRY_USER -p $REGISTRY_PASSWORD $REGISTRY
  # Defines a function that setups and configures the SSH credentials.
  # The ssh-agent doesn't work reliably, so we need to setup the default
  # ssh key by hand here. Usage: setup_ssh
  - |
    function setup_ssh() {
      if [ -z "$SSH_KEY" ] || [ -z "$SSH_FINGERPRINT" ]; then
          echo "ERROR! SSH_KEY or SSH_FINGERPRINT not set!"
          exit 1
      fi

      mkdir -p ~/.ssh
      chmod 700 ~/.ssh
      echo "$SSH_FINGERPRINT" > ~/.ssh/known_hosts
      chmod 644 ~/.ssh/known_hosts
      echo "$SSH_KEY" > ~/.ssh/id_rsa
      chmod 600 ~/.ssh/id_rsa
    }

# ----------------------------------------------------------------------
# Build
# ----------------------------------------------------------------------

# We're Overwrite the COMPOSE_FILE variable in the build section to use
# the compose file that includes build instructions

build_nginx:
  variables:
    COMPOSE_FILE: docker-compose.build.yml
  stage: build
  script:
    - docker-compose build nginx
    - docker-compose push nginx

# ----------------------------------------------------------------------
# Deploy Template
# ----------------------------------------------------------------------

.template_deploy: &deploy_definition
  script:
    - setup_ssh
    # Tag the built images as release images and push them to the registry
    - docker pull $IMAGE/nginx:$TAG
    - docker tag $IMAGE/nginx:$TAG $IMAGE_RELEASE/nginx:$TAG
    - docker push $IMAGE_RELEASE/nginx:$TAG
    - sleep 5
    # Before deployment we log again into the docker registry. The
    # DEPLOYMENT_REGISTRY_USER and DEPLOYMENT_REGISTRY_PASSWORD variables
    # should be set in the job with the credentials that have been manually
    # setup before. Reason for this: The build token generated by GitLab
    # expires after a certain amount of time. But we don't want the registry
    # authentication on the production host to ever expire. That's why we have
    # to setup credentials on our own.
    - docker login -u $DEPLOYMENT_REGISTRY_USER -p $DEPLOYMENT_REGISTRY_PASSWORD $REGISTRY
    # Before deploying the app we need to change the docker host to the
    # machine we actually want to deploy to
    - export DOCKER_HOST=$DEPLOY_DOCKER_HOST
    # Deploy the stack, yay!
    - docker stack deploy -c $COMPOSE_FILE --with-registry-auth --prune $STACK_NAME


# ----------------------------------------------------------------------
# Deploy
# ----------------------------------------------------------------------

deploy_production:
  stage: deploy
  only:
    refs:
      - main
      - master
  environment:
    name: production
    url: https://$PROD_DOMAIN
  variables:
    HOST_NAME: $PROD_DOMAIN
    SSH_KEY: $PROD_SSH_KEY
    SSH_FINGERPRINT: $PROD_SSH_FINGERPRINT
    COMPOSE_FILE: docker-compose.prod.yml
    DEPLOY_DOCKER_HOST: $PROD_DOCKER_HOST
    DEPLOYMENT_REGISTRY_USER: $PROD_REGISTRY_USER
    DEPLOYMENT_REGISTRY_PASSWORD: $PROD_REGISTRY_PASSWORD
  <<: *deploy_definition
